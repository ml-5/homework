*
//朴素做法 时间复杂度O(mn)
for(int i = 1; i <= n; i++) {//遍历字符串s中每一个字母，探索从当前所遍历的字母开始时
//能否与p完全匹配
    bool flag = true;
    for(int j = 1; j <= m；j++) {
        if(s[i+j-1] != p[j]) { //视频中是if(s[i]!=p[j]
            flag = false;
            break;
        }        
    }
}
/*每次匹配过程中，当前一部分完全匹配，s中i所指向的字母与p中j+1所指向的字母不相等时
朴素做法是只往后移动一位，比较浪费前部分已经匹配的信息
KMP思路是能否利用前一部分完全匹配这个信息，多移动几位，并且保证
移动之后仍然去探索s中下标i所指向的字母与p中更新后的下标j+1所指向的字母是否相等
而s中下标i所指向的字母前面那部分与p中更新后的下标j+1所指向的字母前面那部分确定匹配
因此引出最长前缀后缀这个概念，而最长是因为这样移动较少，确定相匹配的字母越多
*/
// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度
求模式串的Next数组：
for (int i = 2, j = 0; i <= m; i ++ )
{
    while (j && p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ;
    ne[i] = j;
}

// 匹配
for (int i = 1, j = 0; i <= n; i ++ )
{
    while (j && s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j ++ ;
    if (j == m)
    {
        j = ne[j];
        // 匹配成功后的逻辑
    }
}
*/
#include <iostream>
using namespace std;

const int N = 100010, M = 1000010;
int n, m;
int ne[N];
char s[M], p[N];

int main()
{//KMP下标习惯从1开始
    cin >> n >> p + 1 >> m >> s + 1;
//求ne数组过程与下面KMP匹配过程非常相似，p可以看成下面KMP匹配的s
//p中以每个字母结尾的p中的那部分字符串可以看成下面的p
    for (int i = 2, j = 0; i <= n; i ++ )
    {//本来也是从1开始，但是对于ne数组而言，ne[1]==0，ne[2]开始可能为1，所以从2开始
        while (j && p[i] != p[j + 1]) j = ne[j];
        if (p[i] == p[j + 1]) j ++ ;
//此时的i与原来的j+1，现在++之后的j匹配，因此得到此时ne[i]=j
        ne[i] = j;
    }
/*
遍历s中每一个字母，每一个字母都可能是刚好从它开始不相等的字母
并且是s中i所指向的字母与p中j+1所指向的字母去比较，所以i既然从1开始，
与之对应的j+1也是从1开始，所以j从0开始
而之所以是j+1与i对应，是因为当s中的某个下标对应的字母和
p中某个下标对应的字母不相等时，我们要去使用的最长前缀后缀长度是
p中不相等的那个下标对应的字母的前面那个字母，所以令前面那个下标为j
s中不相等的那个下标为i，因此得到i与j+1对应
*/
    for (int i = 1, j = 0; i <= m; i ++ )//KMP匹配过程
    {
/*
当s中i所指向的字母与p中j+1所指向的字母不相等时，让j退一点去看j+1与i能否对应
所以while循环的思路是指当j还可以退，也就是不为0时，并且此时的i与j+1还是不相等的话
那j就再退一点
*/
        while (j && s[i] != p[j + 1]) j = ne[j];
//如果跳出循环的原因是因为s中i所指向的字母与p中j+1所指向的字母相等的话，j向后移动
//而i每次遍历都会往后移动一位
        if (s[i] == p[j + 1]) j ++ ;
        if (j == n)
        {
//这里注意此时的j是已经+1之后的j，也就是此时j与i各自所指向的字母是匹配的
//也就是此时输出的s中的起点下标按理说应该是i-n+1,但注意题中所要求的的下标从0开始
//只是我们编程时假定下标从1开始，所以输出的起点下标应该是i-n
//最后在更新一下j
            printf("%d ", i - n);
            j = ne[j];
        }
    }

    return 0;
}