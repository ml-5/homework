//推导大O阶
/*
1.用常数1取代运行时间中所有的加法常数
2.在修改后的运行函数中，只保留最高项
3.如果最高项存在且不为1，则去除这个项相乘的常数
*/
/*
简易的桶排序
此处要注意桶的个数假如说对0~1000之间的数据排序则需要10001个桶
*/
//此处book的意思是标记，记录的意思
#include <stdio.h>
int main()
{
    int book[11], i, j, t;
    for (i = 0; i <= 10; i++)
        book[i] = 0;
    for (i = 1; i <= 5; i++)
    {
        scanf("%d", &t);
        book[t]++;
    }
    for (i = 0; i <= 10; i++)          //依次判断啊a[0]~a[10]
        for (j = 1; j <= book[i]; j++) //出现了几次就打印几次
            printf("%d ", i);
    return 0;
}
/*关于代码复杂度的问题假设m为桶的个数，n为排序的个数挣个算法的执行了2*(m+n)
而它的复杂度为O(M+N)*/
