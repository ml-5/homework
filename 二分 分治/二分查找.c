/**
任务描述：任意给定一个包含n个整数的集合，且n个整数已经按升序排列。任意
给定一个整数k，判断该整数是否在集合中。
输入：每个测试用例包括两行，第一行包含两个整数k和n，其中k表示待查找的
元素，n(n≤10000)表示集合中整数的个数，第二行输入n个整数，数与数之间用
空格隔开。最后一行包含-1，表示输入结束。
输出：每组测试数据的结果输出占一行，如果元素k存在数组中则输出其下标，
否则输出-1。
样例输入：
38 7
13 27 38 49 65 76 97
-1
样例输出：
2
**/
/**思路:
把集合𝐴 = {𝑎 𝑙 , ⋯ , 𝑎[𝑟]}分成个数大致相同的两部分： 𝐴1 = {𝑎 𝑙 , ⋯ , 𝑎[(𝑙 + 𝑟)/2 − 1]}
为第一部分， 𝐴2 = {𝑎 (𝑙 + 𝑟)/2 + 1 , ⋯ , 𝑎[𝑟]}为第二部分
取𝑎 (𝑙 + 𝑟)/2 与𝑘做比较
如果𝑘 > 𝑎[(𝑙 + 𝑟)/2]，则在𝐴2中查找，而𝐴1可以减去不用再考虑；
如果𝑘 < 𝑎[(𝑙 + 𝑟)/2]，则在𝐴1中查找，而𝐴2可以舍弃；
如果𝑘 = 𝑎[(𝑙 + 𝑟)/2]，则已经找到目标元素，输出其下标。
**/
int BinarySearch(int Data[], int Len, int k)
{

    int Left = 0, Right = Len - 1, Mid = 0;
    while (Left <= Right)
    {
        Mid = (Left + Right) / 2;
        if (k == Data[Mid])
            return Mid;
        if (k < Data[Mid])
            Right = Mid - 1;
        else
            Left = Mid + 1;
    }
    return -1;
}