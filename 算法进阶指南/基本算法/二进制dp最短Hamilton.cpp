/* 
朴素做法 O(n*n!) 
优化
在任意时刻如何表示那些点被经过那些点没有被经过？
可以使用一个n位的二进制数,若第i位为1，则表示第i点已经被经过,反之表示没有经过
，在任意时刻需要知道当前的所处的位置
F[i,j](0<=i<2^n,0<=n<j) 表示点经过的状态,对应的处于点j的最短路径
在起点的时候F(1,0)=0,即此时只经过了点0，目标处于起点0，最短路为0
方便起见所有的点(i所有为都是1)，处于终点n-1的最短路
在任意时刻
F[i,j]=min(F[i xor(1<<j),k]+weight(k,j);
*/
