/**
å°æ•°èƒŒåŒ…é—®é¢˜
é—®é¢˜æè¿°ï¼šç»™å®šğ‘›ç§ç‰©å“å’Œä¸€ä¸ªèƒŒåŒ…ã€‚ç‰©å“ğ‘–çš„é‡é‡æ˜¯ğ‘Šğ‘–ï¼Œå…¶ä»·å€¼ä¸ºğ‘‰ğ‘–ï¼ŒèƒŒåŒ…çš„å®¹é‡ä¸ºCï¼Œåº”å¦‚ä½•
é€‰æ‹©è£…å…¥èƒŒåŒ…çš„ç‰©å“ä½¿å¾—è£…å…¥èƒŒåŒ…ä¸­ç‰©å“çš„æ€»ä»·å€¼æœ€å¤§? è¿™é‡Œï¼Œåœ¨é€‰æ‹©ç‰©å“ğ‘–è£…å…¥èƒŒåŒ…æ—¶ï¼Œå¯ä»¥é€‰
æ‹©ç‰©å“ğ‘–çš„ä¸€éƒ¨åˆ†ï¼Œè€Œä¸ä¸€å®šè¦å…¨éƒ¨è£…å…¥èƒŒåŒ…ã€‚
è¾“å…¥ï¼šå¤šç»„æµ‹è¯•æ•°æ®ã€‚æ¯ç»„æµ‹è¯•åŒ…æ‹¬ä¸‰è¡Œï¼šç¬¬ä¸€è¡Œè¾“å…¥ç‰©å“çš„æ€»æ•°ğ‘›(ğ‘› < 1000ï¼‰å’ŒèƒŒåŒ…çš„å®¹é‡
ğ¶(ğ¶ < 1000)ã€‚ç¬¬äºŒè¡Œè¾“å…¥ğ‘›ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºç‰©å“çš„é‡é‡ã€‚ç¬¬ä¸‰è¡Œè¾“å…¥ç‰©å“çš„ä»·å€¼ã€‚
è¾“å‡ºï¼šè¾“å‡ºè£…å…¥èƒŒåŒ…çš„æ€»ä»·å€¼ï¼Œæ¯ç»„æµ‹è¯•æ•°æ®è¾“å‡ºä¸€è¡Œã€‚
è¾“å…¥æ ·ä¾‹ï¼š
3 50
10 20 30
60 100 120
è¾“å‡ºæ ·ä¾‹ï¼š
240
**/
/**
ç­–ç•¥ä¸€ï¼šåœ¨ä¸è¶…å‡ºå½“å‰èƒŒåŒ…çš„å‰©ä½™å®¹é‡å‰æä¸‹ï¼Œä¼˜å…ˆé€‰æ‹©ä»·å€¼æœ€å¤§çš„ç‰©å“ï¼Œè¿™æ ·ä½¿å¾—è£…
å…¥ä»·å€¼å¢é•¿æœ€å¿«ã€‚
ç­–ç•¥äºŒï¼šåœ¨ä¸è¶…å‡ºå½“å‰èƒŒåŒ…çš„å‰©ä½™å®¹é‡å‰æä¸‹ï¼Œä¼˜å…ˆé€‰æ‹©é‡é‡æœ€è½»çš„ç‰©å“ï¼Œè¿™æ ·ä½¿å¾—èƒŒåŒ…
å®¹é‡å¢é•¿æœ€æ…¢ã€‚
ç­–ç•¥ä¸‰ï¼šåœ¨ä¸è¶…å‡ºå½“å‰èƒŒåŒ…çš„å‰©ä½™å®¹é‡å‰æä¸‹ï¼Œä¼˜å…ˆé€‰æ‹©ä»·å€¼ç‡ï¼ˆä»·å€¼é™¤ä»¥é‡é‡ï¼‰æœ€
å¤§çš„ç‰©å“ï¼Œè¿™æ ·ä½¿å¾—èƒŒåŒ…ä¸­å•ä½é‡é‡ä»·å€¼å¢é•¿æœ€å¿«ã€‚
ç­–ç•¥ä¸‰ä¸ºæœ€ä¼˜

å°æ•°èƒŒåŒ…é—®é¢˜çš„è´ªå¿ƒç®—æ³•æ€è·¯
1. é¢„å¤„ç†ï¼ŒæŠŠç‰©å“æŒ‰ç…§ä»·å€¼ç‡è¿›è¡Œé™åºæ’åˆ—
2. é€‰æ‹©ç¬¬ä¸€ä¸ªç‰©å“ æ ¹æ®è´ªå¿ƒç­–ç•¥ï¼Œé¦–å…ˆé€‰æ‹©ä»·å€¼ç‡æœ€å¤§çš„ç‰©å“ï¼Œå¹¶è®°å½•è¯¥ç‰©
å“è£…å…¥çš„é‡é‡ã€‚
3. è´ªå¿ƒé€‰æ‹©åç»­æ´»åŠ¨ ä¾æ¬¡æ‰«ææ¯ä¸€ä¸ªç‰©å“ï¼Œåœ¨æ²¡æœ‰è¶…å‡ºèƒŒåŒ…å®¹é‡çš„æ¡ä»¶ä¸‹ï¼Œ
å°½å¯èƒ½å¤šåœ°è£…å…¥å½“å‰ä»·å€¼ç‡æœ€é«˜çš„ç‰©å“ï¼Œå¹¶è®°å½•è¯¥ç‰©å“è£…å…¥çš„é‡é‡ã€‚
**/
#include <stdio.h>
#include <algorithm>
using namespace std;
#define MaxItems 1000
struct item
{
    int weight;
    int value;
    bool operator<(const item &bb) const
    {                                                                 //å®šä¹‰æ¯”è¾ƒå‡½æ•°ï¼ˆå°äºå·ï¼‰
        return value / (1.0 * weight) > (1.0 * bb.value) / bb.weight; //ä¸ºä»€ä¹ˆä¹˜ä»¥1.0ï¼Ÿ
    }
}; //å®šä¹‰ç‰©å“çš„ç»“æ„ä½“
double greedyKnapsack(int n, int capacity, item *itemSet)
{
    double ans = 0;
    sort(itemSet, itemSet + n); //STLä¸­çš„å¿«é€Ÿæ’åºç®—æ³•
    for (int i = 0; i < n; i++)
        if (capacity >= itemSet[i].weight)
        {
            ans += itemSet[i].value; //é€‰æ‹©å•ä»·æœ€å¤§çš„ç‰©å“
            capacity -= itemSet[i].weight;
        }
        else
        {
            ans += capacity * (itemSet[i].value * 1.0) / itemSet[i].weight; //æœ€åä¸€ä¸ªç‰©å“åªèƒ½è£…éƒ¨åˆ†
            break;
        }
    return ans;
}