/**

活动安排问题

假设某社团某一天要组织𝑛个活动𝐸 = {1, 2, ⋯ , 𝑛} ，其中每个活动都要求使用同一礼堂，而且
在同一时间内只有一个活动能使用这个礼堂。每个活动𝑖都有一个要求使用礼堂的起始时间𝑠𝑖
和结束时间 𝑓𝑖，且有𝑠𝑖 < 𝑓𝑖。如果选择了活动𝑖，则它在半开时间区间[𝑠𝑖, 𝑓𝑖) 内占用资源。若
区间[𝒔𝒊, 𝒇𝒊) 与区间[𝒔𝒋, 𝒇𝒋) 不相交，则称活动𝐢与活动𝐣是相容的。现在给定𝑛个活动的开始时
间和结束时间，请设计一个活动安排方案，使得安排的相容活动数目最多。
**/
/**
策略一：选择具有最早开始时间，而且不与已安排的活动冲突的活动。
策略二：选择具有最短使用时间，而且不与已安排的活动冲突的活动。
策略三：选择具有最早结束时间，而且不与已安排的活动冲突的活动。
显然一二合并之后得到的策略三是最佳决策

信息：
s[i] 1 0 3 3 5 5 6 8 8 2 12
f[i] 4 6 5 8 7 9 10 11 12 13 14

i    1 2 3 4 5 6 7 8 9 10 11
s[i] 1 3 0 5 3 5 6 8 8 2 12
f[i] 4 5 6 7 8 9 10 11 12 13 14
活动安排问题的贪心算法设计思路如下：
1. 预处理 把所有的活动按照结束时间进行升序排列，有𝑓[1] ≤ 𝑓[2] ≤ ⋯ ≤ 𝑓[𝑛]
2. 选择第一个活动 选择结束时间最早的活动 𝐸[1]，当前决策𝑠𝑒𝑙𝑒𝑐𝑡𝑒𝑑 = 1 3. 
3. 贪心选择后续活动 依次扫描后续的每一个活动𝐸[𝑖]，如果𝐸[𝑖]的开始时间晚于上一个
选择的活动E[selected ]的结束时间，则安排当前活动𝐸[𝑖]，令𝑠𝑒𝑙𝑒𝑐𝑡𝑒𝑑 = 𝑖；否则放弃
𝐸[𝑖] 。
**/
#include <stdio.h>
int GreedyEvenSchedule(int n, int *timeStart, int *timeFinsh)
{
    int i, j, selected, ans = 0;
    //冒泡排序，使得活动按结束时间升序排列
    for (i = 0; i < n; i++)
        for (j = 0; j + 1 < n; j++)
            if (timeFinish[j] > timeFinish[j + 1])
            {
                swap(timeFinish[j], timeFinish[j + 1]);
                swap(timeStart[j], timeStart[j + 1]); //注意开始时间也需一致移动
            }
    selected = 0; //选择第一个活动
    ans = 1;
    ans = 1;
    for (i = 1; i < n; i++)
        if (timeStart[i] >= timeFinish[selected])
        {
            selected = i; //选择相容的最早结束活动
            ans++;
        }
    return ans;
}