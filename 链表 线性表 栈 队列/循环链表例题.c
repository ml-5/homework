/**
循环单链表：将表中尾节点的指针域改为
指向表头节点，整个链表形成一个环。由
此从表中任一节点出发均可找到链表中其
它节点
循环双链表：形成两个环。
与非循环单链表相比，循环单链表：
链表中没有空指针域
p所指节点为尾节点的条件：p->next==L

2、循环双链表
与非循环双链表相比，循环双链表
链表中没有空指针域
p所指节点为尾节点的条件：p->next==L
一步操作即L->prior可以找到尾节点

**/
/**
 * 例题:某线性表最常用的操作是在尾元素之后插入一个
元素和删除第一个元素，故采用D存储方式最节省运算时间
A.单链表
B.仅有头结点指针的循环单链表
C.双链表                     O(n) O(1)
D.仅有尾结点指针的循环单链表   因为:时间复杂度均为O(1)

如果对含有n（n>1）个元素的线性表的运算只有4种，
即删除第一个元素、删除尾元素、在第一个元素前面插入新元素、
在尾元素的后面插入新元素，则最好使用 C 。
A.只有尾结点指针没有头结点的循环单链表
B.只有尾结点指针没有头结点的非循环双链表
C.只有首结点指针没有尾结点指针的循环双链表
D.既有头指针也有尾指针的循环单链表
分析时间复杂度易知选C

设计判断带头节点的循环双链表L（含两个以
上的节点）是否对称相等的算法。

思路:p从左向右扫描L，q从右向左扫描L 
若对应数据节点的data域不相等，则退出循环
否则继续比较，直到p与q相等或p的下一个节点为*q为止。
**/
int Equal(DLinkList *L)
{
    int same=1;
    DLinkList *p=L->next,*q=L->prior;//p指向第一个数据节点，q指向最后的数据节点
    while(same==1)
    {
        if(p->data!=q->data)
        same=0
        else
        {
            if(p==q||p==q->prior) break;
            q=q->prior;//q前移
            p=p->next;//p后移
        }
    }
    return same;
}